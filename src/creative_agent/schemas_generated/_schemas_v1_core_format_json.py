# generated by datamodel-codegen:
#   filename:  _schemas_v1_core_format_json.json

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Optional, Union

from pydantic import AnyUrl, BaseModel, ConfigDict, Field


class Type(Enum):
    audio = "audio"
    video = "video"
    display = "display"
    native = "native"
    dooh = "dooh"
    rich_media = "rich_media"
    universal = "universal"


class AssetType(Enum):
    image = "image"
    video = "video"
    audio = "audio"
    text = "text"
    html = "html"
    javascript = "javascript"
    url = "url"
    brand_manifest = "brand_manifest"


class AssetsRequired(BaseModel):
    asset_id: Annotated[
        str, Field(description="Identifier for this asset in the format")
    ]
    asset_type: Annotated[AssetType, Field(description="Type of asset")]
    asset_role: Annotated[
        Optional[str],
        Field(
            description="Purpose of this asset (e.g., 'hero_image', 'logo', 'headline', 'cta_button')"
        ),
    ] = None
    required: Annotated[
        Optional[bool], Field(description="Whether this asset is required")
    ] = None
    requirements: Annotated[
        Optional[dict[str, Any]],
        Field(
            description="Technical requirements for this asset (dimensions, file size, duration, etc.)"
        ),
    ] = None


class Repeatable(Enum):
    boolean_true = True


class Asset(BaseModel):
    asset_id: Annotated[
        str, Field(description="Identifier for this asset within the group")
    ]
    asset_type: Annotated[AssetType, Field(description="Type of asset")]
    asset_role: Annotated[Optional[str], Field(description="Purpose of this asset")] = (
        None
    )
    required: Annotated[
        Optional[bool],
        Field(description="Whether this asset is required in each repetition"),
    ] = None
    requirements: Annotated[
        Optional[dict[str, Any]],
        Field(description="Technical requirements for this asset"),
    ] = None


class AssetsRequired1(BaseModel):
    asset_group_id: Annotated[
        str,
        Field(
            description="Identifier for this asset group (e.g., 'product', 'slide', 'card')"
        ),
    ]
    repeatable: Annotated[
        Repeatable, Field(description="Indicates this is a repeatable asset group")
    ]
    min_count: Annotated[
        int, Field(description="Minimum number of repetitions required", ge=1)
    ]
    max_count: Annotated[
        int, Field(description="Maximum number of repetitions allowed", ge=1)
    ]
    assets: Annotated[
        list[Asset], Field(description="Assets within each repetition of this group")
    ]


class Format(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    format_id: Annotated[str, Field(description="Unique identifier for the format")]
    agent_url: Annotated[
        Optional[AnyUrl],
        Field(
            description="Base URL of the agent that provides this format (authoritative source). E.g., 'https://reference.adcp.org', 'https://dco.example.com'"
        ),
    ] = None
    name: Annotated[str, Field(description="Human-readable format name")]
    description: Annotated[
        Optional[str],
        Field(
            description="Plain text explanation of what this format does and what assets it requires"
        ),
    ] = None
    preview_image: Annotated[
        Optional[AnyUrl],
        Field(
            description="Optional preview image URL for format browsing/discovery UI"
        ),
    ] = None
    example_url: Annotated[
        Optional[AnyUrl],
        Field(
            description="Optional URL to showcase page with examples and interactive demos of this format"
        ),
    ] = None
    type: Annotated[
        Type,
        Field(
            description="Media type of this format - determines rendering method and asset requirements"
        ),
    ]
    requirements: Annotated[
        Optional[dict[str, Any]],
        Field(
            description="Technical specifications for this format (e.g., dimensions, duration, file size limits, codecs)"
        ),
    ] = None
    assets_required: Annotated[
        Optional[list[Union[AssetsRequired, AssetsRequired1]]],
        Field(
            description="Array of required assets or asset groups for this format. Can contain individual assets or repeatable asset sequences (e.g., carousel products, slideshow frames)."
        ),
    ] = None
    delivery: Annotated[
        Optional[dict[str, Any]],
        Field(
            description="Delivery method specifications (e.g., hosted, VAST, third-party tags)"
        ),
    ] = None
    supported_macros: Annotated[
        Optional[list[str]],
        Field(
            description="List of universal macros supported by this format (e.g., MEDIA_BUY_ID, CACHEBUSTER, DEVICE_ID). Used for validation and developer tooling."
        ),
    ] = None
    output_format_ids: Annotated[
        Optional[list[str]],
        Field(
            description="For generative formats: array of format IDs that this format can generate. When a format accepts inputs like brand_manifest and message, this specifies what concrete output formats can be produced (e.g., a generative banner format might output standard image banner formats)."
        ),
    ] = None
