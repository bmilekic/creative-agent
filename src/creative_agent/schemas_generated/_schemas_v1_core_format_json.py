# generated by datamodel-codegen:
#   filename:  _schemas_v1_core_format_json.json

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Optional, Union

from pydantic import AnyUrl, BaseModel, ConfigDict, Field


class FormatId(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    agent_url: Annotated[
        AnyUrl,
        Field(
            description="URL of the agent that defines this format (e.g., 'https://creatives.adcontextprotocol.org' for standard formats, or 'https://publisher.com/.well-known/adcp/sales' for custom formats)"
        ),
    ]
    id: Annotated[
        str,
        Field(
            description="Format identifier within the agent's namespace (e.g., 'display_300x250', 'video_standard_30s')",
            pattern="^[a-zA-Z0-9_-]+$",
        ),
    ]


class Type(Enum):
    audio = "audio"
    video = "video"
    display = "display"
    native = "native"
    dooh = "dooh"
    rich_media = "rich_media"
    universal = "universal"


class Responsive(BaseModel):
    width: bool
    height: bool


class Unit(Enum):
    px = "px"
    dp = "dp"
    inches = "inches"
    cm = "cm"


class Dimensions(BaseModel):
    width: Annotated[
        Optional[float], Field(description="Fixed width in specified units", ge=0.0)
    ] = None
    height: Annotated[
        Optional[float], Field(description="Fixed height in specified units", ge=0.0)
    ] = None
    min_width: Annotated[
        Optional[float],
        Field(description="Minimum width for responsive renders", ge=0.0),
    ] = None
    min_height: Annotated[
        Optional[float],
        Field(description="Minimum height for responsive renders", ge=0.0),
    ] = None
    max_width: Annotated[
        Optional[float],
        Field(description="Maximum width for responsive renders", ge=0.0),
    ] = None
    max_height: Annotated[
        Optional[float],
        Field(description="Maximum height for responsive renders", ge=0.0),
    ] = None
    responsive: Annotated[
        Optional[Responsive],
        Field(description="Indicates which dimensions are responsive/fluid"),
    ] = None
    aspect_ratio: Annotated[
        Optional[str],
        Field(
            description="Fixed aspect ratio constraint (e.g., '16:9', '4:3', '1:1')",
            pattern="^\\d+:\\d+$",
        ),
    ] = None
    unit: Annotated[Unit, Field(description="Unit of measurement for dimensions")]


class Render(BaseModel):
    role: Annotated[
        str,
        Field(
            description="Semantic role of this rendered piece (e.g., 'primary', 'companion', 'mobile_variant')"
        ),
    ]
    dimensions: Annotated[
        Dimensions, Field(description="Dimensions for this rendered piece")
    ]


class AssetType(Enum):
    image = "image"
    video = "video"
    audio = "audio"
    vast = "vast"
    daast = "daast"
    text = "text"
    html = "html"
    css = "css"
    javascript = "javascript"
    url = "url"
    webhook = "webhook"
    promoted_offerings = "promoted_offerings"


class AssetsRequired(BaseModel):
    asset_id: Annotated[
        str,
        Field(
            description="Unique identifier for this asset. Creative manifests MUST use this exact value as the key in the assets object."
        ),
    ]
    asset_type: Annotated[AssetType, Field(description="Type of asset")]
    asset_role: Annotated[
        Optional[str],
        Field(
            description="Optional descriptive label for this asset's purpose (e.g., 'hero_image', 'logo'). Not used for referencing assets in manifests—use asset_id instead. This field is for human-readable documentation and UI display only."
        ),
    ] = None
    required: Annotated[
        Optional[bool], Field(description="Whether this asset is required")
    ] = None
    requirements: Annotated[
        Optional[dict[str, Any]],
        Field(
            description="Technical requirements for this asset (dimensions, file size, duration, etc.)"
        ),
    ] = None


class Repeatable(Enum):
    boolean_true = True


class Asset(BaseModel):
    asset_id: Annotated[
        str, Field(description="Identifier for this asset within the group")
    ]
    asset_type: Annotated[AssetType, Field(description="Type of asset")]
    asset_role: Annotated[
        Optional[str],
        Field(
            description="Optional descriptive label for this asset's purpose (e.g., 'hero_image', 'logo'). Not used for referencing assets in manifests—use asset_id instead. This field is for human-readable documentation and UI display only."
        ),
    ] = None
    required: Annotated[
        Optional[bool],
        Field(description="Whether this asset is required in each repetition"),
    ] = None
    requirements: Annotated[
        Optional[dict[str, Any]],
        Field(description="Technical requirements for this asset"),
    ] = None


class AssetsRequired1(BaseModel):
    asset_group_id: Annotated[
        str,
        Field(
            description="Identifier for this asset group (e.g., 'product', 'slide', 'card')"
        ),
    ]
    repeatable: Annotated[
        Repeatable, Field(description="Indicates this is a repeatable asset group")
    ]
    min_count: Annotated[
        int, Field(description="Minimum number of repetitions required", ge=1)
    ]
    max_count: Annotated[
        int, Field(description="Maximum number of repetitions allowed", ge=1)
    ]
    assets: Annotated[
        list[Asset], Field(description="Assets within each repetition of this group")
    ]


class Format(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    format_id: Annotated[
        FormatId,
        Field(
            description="Structured format identifier with agent URL and format name",
            title="Format ID",
        ),
    ]
    name: Annotated[str, Field(description="Human-readable format name")]
    description: Annotated[
        Optional[str],
        Field(
            description="Plain text explanation of what this format does and what assets it requires"
        ),
    ] = None
    preview_image: Annotated[
        Optional[AnyUrl],
        Field(
            description="Optional preview image URL for format browsing/discovery UI. Should be 400x300px (4:3 aspect ratio) PNG or JPG. Used as thumbnail/card image in format browsers."
        ),
    ] = None
    example_url: Annotated[
        Optional[AnyUrl],
        Field(
            description="Optional URL to showcase page with examples and interactive demos of this format"
        ),
    ] = None
    type: Annotated[
        Type,
        Field(
            description="Media type of this format - determines rendering method and asset requirements"
        ),
    ]
    renders: Annotated[
        Optional[list[Render]],
        Field(
            description="Specification of rendered pieces for this format. Most formats produce a single render. Companion ad formats (video + banner), adaptive formats, and multi-placement formats produce multiple renders. Each render specifies its role and dimensions.",
            min_length=1,
        ),
    ] = None
    assets_required: Annotated[
        Optional[list[Union[AssetsRequired, AssetsRequired1]]],
        Field(
            description="Array of required assets or asset groups for this format. Each asset is identified by its asset_id, which must be used as the key in creative manifests. Can contain individual assets or repeatable asset sequences (e.g., carousel products, slideshow frames)."
        ),
    ] = None
    delivery: Annotated[
        Optional[dict[str, Any]],
        Field(
            description="Delivery method specifications (e.g., hosted, VAST, third-party tags)"
        ),
    ] = None
    supported_macros: Annotated[
        Optional[list[str]],
        Field(
            description="List of universal macros supported by this format (e.g., MEDIA_BUY_ID, CACHEBUSTER, DEVICE_ID). Used for validation and developer tooling."
        ),
    ] = None
    output_format_ids: Annotated[
        Optional[list[Any]],
        Field(
            description="For generative formats: array of format IDs that this format can generate. When a format accepts inputs like brand_manifest and message, this specifies what concrete output formats can be produced (e.g., a generative banner format might output standard image banner formats)."
        ),
    ] = None
